#include "XSCommon/XSCommon.h"
#include "XSCommon/XSError.h"
#include "XSCommon/XSString.h"
#include "XSCommon/XSCvar.h"
#include "XSCommon/XSConsole.h"
#include "XSCommon/XSVector.h"
#include "XSCommon/XSTimer.h"
#include "XSCommon/XSGlobals.h"
#include "XSClient/XSClient.h"
#include "XSClient/XSClientGame.h"
#include "XSClient/XSClientConsole.h"
#include "XSRenderer/XSFont.h"
#include "XSRenderer/XSView.h"

namespace XS {

	namespace Client {

		uint64_t frameNum = 0u;

		static Renderer::View *hudView = nullptr;
		static Cvar *cl_drawFPS = nullptr;

		ClientConsole *clientConsole = nullptr;

		void Cmd_ToggleConsole( const commandContext_t * const context ) {
			if ( !clientConsole ) {
				throw XSError( "Tried to toggle client console without a valid instance" );
			}

			clientConsole->Toggle();
		}

		void Init( void ) {
			cl_drawFPS = Cvar::Create( "cl_drawFPS", "0", "Show the current framerate", CVAR_ARCHIVE );

			ClientGame::Init();

			// hud
			const uint32_t width = Cvar::Get( "vid_width" )->GetInt();
			const uint32_t height = Cvar::Get( "vid_height" )->GetInt();
			hudView = new Renderer::View( width, height );

			clientConsole = new ClientConsole( &console );
		}

		void Shutdown( void ) {
		}

		void NetworkPump( void ) {
			// create game context from any server updates we receieved since the last frame
		}

		void RunFrame( double dt ) {
			static double stepTime = 0.0;
			frameNum++;

			// previousState = currentState;
			// integrate( currentState, stepTime, dt );
			stepTime += dt;

			// process server updates
			// simulate local entities
			//	predict entities whose state is not managed by the server, created by either the client or server
			//	e.g. client may create its own projectiles until the server overrides it
			// movement prediction (movement commands have been generated by input poll)
			ClientGame::RunFrame();
		}

		double GetElapsedTime( Timer::Resolution resolution ) {
			static uint64_t lastFrame = 0u;
			static double timeSec = 0.0;
			static double timeMsec = 0.0;
			static double timeUsec = 0.0;
			if ( lastFrame != frameNum ) {
				lastFrame = frameNum;
				timeUsec = Common::gameTimer->GetTiming();
				timeMsec = timeUsec * 0.001;
				timeSec = timeUsec * 0.000001;
			}

			switch( resolution ) {

				case Timer::Resolution::SECONDS: {
					return timeSec;
				} break;

				case Timer::Resolution::MILLISECONDS: {
					return timeMsec;
				} break;

				case Timer::Resolution::MICROSECONDS: {
					return timeUsec;
				} break;

				default: {
					return 0.0;
				} break;
			}
		}

		static void DrawHUD( double frametime ) {
			hudView->Bind();

			static const vector2 pos = vector2( 0.0f, 0.0f );
			static Renderer::Font *font = nullptr;
			if ( !font ) {
				font = Renderer::Font::Register( "menu", 16 );
			}

			static const uint32_t numSamples = 128u;
			static double samples[numSamples];
			static uint32_t index = 0;
			samples[index++] = frametime;
			if ( index >= numSamples ) {
				index = 0u;
			}
			double avg = 0.0;
			for ( uint32_t i = 0; i < numSamples; i++ ) {
				avg += samples[i];
			}
			avg /= (double)numSamples;
			if ( cl_drawFPS->GetBool() ) {
				font->Draw( pos, String::Format( "FPS:%.3f", 1000.0 / avg ) );
			}
		}

		void DrawFrame( double frametime ) {
			// draw game view
			ClientGame::DrawFrame();

			// draw HUD
			DrawHUD( frametime );

			// draw console
			clientConsole->Draw();
		}

	} // namespace Client

} // namespace XS
